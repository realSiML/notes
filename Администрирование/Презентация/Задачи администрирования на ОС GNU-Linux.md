
***

## Содержание

 - [[#Очистка диска]]
 - [[#Сканирование диска]]
 - [[#Дефрагментация]]
 - [[#Резервное копирование]]

***

## Очистка диска

За основу была взята [статья](https://itsfoss.com/free-up-space-ubuntu-linux/) из web портала -  [It's FOSS - World's Leading Linux & Open Source Web Portal](https://itsfoss.com/)

Со временем любая операционная система может загромождаться по мере добавления и удаления программ. Если у вас есть около 1 ТБ емкости для хранения, вы можете не утруждаться очисткой системы на GNU/Linux, чтобы освободить место на диске. Но если ваш жесткий диск имеет ограниченное пространство, например, ноутбук с твердотельным накопителем на 128 ГБ, освобождение дискового пространства становится необходимостью.

### Проверка свободного места на диске

[`df`](https://losst.pro/komanda-df-linux) (disk free) — утилита в UNIX и UNIX-подобных системах, показывает список всех файловых систем по именам устройств, сообщает их размер, занятое и свободное пространство и точки монтирования.

Например:

```bash
df -Th
```

![[Снимок экрана от 2022-11-29 08-09-57.png]]

[`du`](https://losst.pro/komanda-du-v-linux) (disk usage) — стандартная Unix-программа для оценки занимаемого файлового пространства. По умолчанию показывает размер файлового пространства, занимаемого каждым файлом и каталогом в текущем каталоге.

Например:

```bash
sudo du -sh /var/cache/apt 
```

![Clean up cache in Ubuntu Linux](https://itsfoss.com/wp-content/uploads/2017/06/clean-up-space-ubuntu-linux-2.png)

Проверить свободно место на диске графически намного проще в **Ubuntu** с помощью **`Анализатора использования дисков`**.

![Disk Usage Analyzer Tool Linux](https://itsfoss.com/wp-content/uploads/2020/11/disk-usage-analyzer-tool-linux.jpg)

![Free Disk Space Ubuntu Desktop](https://itsfoss.com/wp-content/uploads/2020/11/free-disk-space-ubuntu-desktop-800x648.png)
![Disk Usage Analyzer (Baobab)](https://pingvinus.ru/cr_images/screenshot/1065t-baobab-3.4.1.png)

Или с помощью **`Gnome Disk Utility`**.

![Disks Tool Linux](https://itsfoss.com/wp-content/uploads/2020/11/disks-tool-linux.jpg)

![Free Disk Space Check Ubuntu Desktop](https://itsfoss.com/wp-content/uploads/2020/11/free-disk-space-check-ubuntu-desktop.png)

### Как освободить место на диске (Консоль)

Есть множество способов как очистить дисковое пространство в **Ubuntu** или других **основанных на  Ubuntu** системах. Ниже приведены несколько "**command-line tricks**" (инструкций командной строки), а также варианты утилит с графическим интерфейсом.

#### 1. Избавиться от ненужных пакетов [Рекомендуется]

У команды `apt-get`  есть опция `autoremove` (автоудаление).

С помощью нее можно удалить библиотеки и пакеты, которые были установлены автоматически для удовлетворения зависимостей другого установленного пакета. Если этот пакет удален, то эти автоматически установленные пакеты бесполезны в системе. Эта команда удаляет такие пакеты.

>Удаляемые пакеты часто называют "неиспользуемыми зависимостями". На самом деле, хорошей практикой является использование `autoremove` после удаления пакета, чтобы быть уверенным, что не осталось ненужных файлов

Она также удаляет *старые ядра Linux*, которые были **автоматически** установлены при обновлении системы.

Например:

```bash
sudo apt-get autoremove
```

![Free up space with autoremove command](https://itsfoss.com/wp-content/uploads/2017/06/clean-up-space-ubuntu-linux-1.png)

В итоге освободим 300 МБ дискового пространства.

#### 2. Удалить ненужные приложения [Рекомендуется]

Вы можете удалить программу в Ubuntu из **`центра приложений Ubuntu`**:

![Find installed software in Ubuntu](https://itsfoss.com/wp-content/uploads/2017/06/find-installed-software-ubuntu.jpeg)

Или использовать приведенную ниже команду с конкретными именами приложений:

```bash
sudo apt-get remove package-name1 [package-name2 ...]
```

Или:

```bash
sudo apt-get purge package-name1 [package-name2 ...]
```

##### Какая разница между `apt-get remove` и `apt-get purge`?

-   `apt-get remove` просто удаляет двоичные файлы пакета. Она не трогает конфигурационные файлы
-   `apt-get purge` удаляет все, что связано с пакетом, включая конфигурационные файлы

Таким образом, если вы "удалили" (removed) определенный кусочек программного обеспечения и затем установите его снова, ваша система будет иметь те же самые конфигурационные файлы. Конечно, вас попросят переопределить существующие конфигурационные файлы при повторной установке.

Очистка особенно полезна, когда вы испортили конфигурацию программы, когда вы хотите полностью стереть ее следы из системы и начать все заново.

В большинстве случаев простого удаления более чем достаточно для удаления пакета.

#### 3. Очистка кэша APT

Ubuntu использует [APT](https://wiki.debian.org/Apt) (Advanced Package Tool) для установки, удаления и управления пакетами в системе, в то же время он хранит в кэше скачанные и установленные пакеты даже после того, как они были удалены (uninstalled).

DEB пакеты хранятся в кэше по пути: `/var/cache/apt/archives`. Со временем этот кэш может стать очень большим и содержать много ненужных пакктов.

Можно узнать размер этого кэша командой `du`:

```bash
sudo du -sh /var/cache/apt 
```

Можем увидеть такую картину:

![Clean up cache in Ubuntu Linux](https://itsfoss.com/wp-content/uploads/2017/06/clean-up-space-ubuntu-linux-2.png)

У нас есть 2 варианта очистки кэша.

- Либо удалить только старые версии пакетов, которых больше нет в репозитории

```bash
sudo apt-get autoclean
```

- Или удалить кэш полностью

```bash
sudo apt-get clean
```

#### 4. Очистка журнала systemd

Systemd — подсистема инициализации и управления службами в Linux

Журнал systemd — это собственная система журналирования systemd. Она собирает и хранит данные журнала ядра, сообщения системного журнала, стандартный вывод и ошибки для различных системных служб.

Машина Linux с systemd записывает журналы в каталог `/var/log/journal`.

Проблема в том, что со временем эти журналы занимают значительный объем дискового пространства.

Вы можете проверить размер журнала с помощью этой команды:

```bash
journalctl --disk-usage
```

Есть [несколько способов](https://linuxhandbook.com/clear-systemd-journal-logs/) очистки этого журнала. 

Два простейших из них:

1. Удалить логи, которые старше X дней

```bash
sudo journalctl --vacuum-time=Xd
```

2.  Сократить логи до определенного размера

```bash
sudo journalctl --vacuum-size=XY
```

где `Y` может быть T для ТБ, G для ГБ, M для МБ, K для КБ и. т. д

Пример:

```
$ journalctl --disk-usage
Archived and active journals take up 1.8G in the file system.

$ sudo journalctl --vacuum-time=3d
Vacuuming done, freed 1.7G of archived journals from /var/log/journal/1b9ab93094fa2984beba73fd3c48a39c
```

#### 5. Удалить старые версии Snap приложений

Вы, наверное, уже знаете, что пакеты **Snap** больше по размеру. Кроме того, Snap хранит как минимум две более старые версии приложения (на случай, если вы захотите вернуться к более старой версии). Это съедает огромный кусок пространства.

Например:

```
du -h /var/lib/snapd/snaps
4.0K    /var/lib/snapd/snaps/partial
5.6G    /var/lib/snapd/snaps
```

**Alan Pope**, член команды **Snapcraft** в **Canonical**, создал небольшой скрипт, который вы можете использовать и запускать для очистки всех старых версий ваших приложений Snap.

Вам надо [создать новый shell-скрипт](https://linuxhandbook.com/run-shell-script/) с кодом ниже:

```bash
#!/bin/bash
# Removes old revisions of snaps
# CLOSE ALL SNAPS BEFORE RUNNING THIS
set -eu
snap list --all | awk '/disabled/{print $1, $3}' |
    while read snapname revision; do
        snap remove "$snapname" --revision="$revision"
    done
```

Дать этому файлу права на выполнение и запустить его с правами суперпользователя.

В нашем примере, в итоге, скрипт удалил старые пакеты Snap и освободил более половины 5 ГБ пространства, используемого Snap.

```
du -h /var/lib/snapd/snaps
4.0K    /var/lib/snapd/snaps/partial
2.5G    /var/lib/snapd/snaps
```

#### 6. Очистка кэша миниатюр

Ubuntu автоматически создает миниатюру для просмотра в файловом менеджере. Он хранит эти эскизы в скрытом каталоге в вашей учетной записи пользователя по адресу `~/.cache/thumbnails` .

Со временем количество миниатюр резко увеличится. Более того, кэш эскизов со временем будет содержать множество лишних эскизов изображений, которых больше не существует.

Вы можете проверить размер кэша миниатюр с помощью команды ниже:

```bash
du -sh ~/.cache/thumbnails
```

В нашем примере, размер кэша миниатюр составляет более 300 МБ.

![Clean thumbnail cache to free up space in Ubuntu](https://itsfoss.com/wp-content/uploads/2017/06/clean-up-space-ubuntu-linux-3.png)

Поэтому рекомендуется очищать кэш эскизов каждые несколько месяцев или около того. Самый быстрый способ - использовать терминал:

```bash
rm -rf ~/.cache/thumbnails/*
```

#### 7. Найти и удалить дубликаты файлов

Иногда у вас могут быть дубликаты файлов в разных местах вашей системы. Избавление от дубликатов, безусловно, освободит место и очистит вашу систему Ubuntu.

Для этой задачи вы можете использовать инструмент с графическим интерфейсом, такой как `FSlint`, или инструмент командной строки, такой как `FDUPES`. Рекомендуется прочитать [эту](https://itsfoss.com/find-duplicate-files-linux/) статью, чтобы узнать, как использовать эти инструменты для удаления дубликатов файлов.

![Use FSlint tool find duplicate files in Linux](https://itsfoss.com/wp-content/uploads/2017/08/FSlint-dashboard.jpg)

![fdupes-tutorials](https://itsfoss.com/wp-content/uploads/2017/08/fdupes-tutorials-800x387.jpg)

#### Удалить старые ядра Linux, которые были установлены вручную*

Команда `sudo apt-get autoremove` удаляла старые ядра Linux, но не те которые были установлены вручную.

Выводим список всех установленных ядер Linux:

```bash
sudo dpkg --list 'linux-image*'
```

Удаляем старые образы ядра:

```bash
sudo apt-get remove linux-image-VERSION
```

Рекомендуется оставлять минимум 2-3 ядра, включая новейшее. Таким образом, у вас будет 1-2 опции запуска системы с соответствующим ядром, если по какой-то причине вы не смогли запуститься с новейшим.

#### Удалить осиротевшие пакеты (orphaned packages)*

Предположим, вы установили пакет ‘myprogram’. Но этот пакет имеет зависимость от библиотеки ‘mylib’. Эта библиотека обычно устанавливается автоматически с помощью ‘myprogram’. Когда вы удаляете ‘myprogram’, mylib все еще может оставаться в системе. Таким образом, mylib, в данном случае, становится **осиротевшим пакетом**.

Команда `sudo apt-get autoremove` удаляет такие потерянные пакеты. Но представьте себе случай, когда вы вручную установили ‘mylib‘ перед установкой ‘myprogram‘. Команда ‘apt autoremove’ в этом случае может не удалить потерянный пакет. И, следовательно, вам придется удалить его вручную.

Сначала вам нужно будет найти все потерянные пакеты, а затем удалить их.

Сделать нам это поможет консольная утилита `deborphan`.

```bash
sudo apt-get install deborphan
```

С помощью команды `deborphan` выводится список осиротевших пакетов.

Таким образом мы можем удалить все эти пакеты командой:

```bash
sudo apt-get remove `deborphan`
```

### Как освободить место на диске (GUI)

## Сканирование диска (FSCK)

[Оригинальная статья](https://losst.pro/kak-vosstanovit-fajlovuyu-sistemu-v-fsck)

Из-за различных неполадок или неожиданного отключения компьютера файловая система может быть повреждена. При обычном выключении все файловые системы монтируются только для чтения, а все не сохраненные данные записываются на диск.

Но если питание выключается неожиданно, часть данных теряется, и могут быть потерянны важные данные, что приведет к повреждению самой файловой системы. Рассмотрим как восстановить файловую систему с помощью утилиты **fsck**.

### Немного теории

Как вы знаете файловая система содержит всю информацию обо всех хранимых на компьютере файлах. Это сами данные файлов и метаданные, которые управляют расположением и атрибутами файлов в файловой системе. Данные не сразу записываются на жесткий диск, а некоторое время находятся в оперативной памяти и при неожиданном выключении, за определенного стечения обстоятельств файловая система может быть повреждена.

Современные файловые системы делятся на два типа - журналируемые и нежурналируемые. Журналиуемые файловые системы записывают в лог все действия, которые собираются выполнить, а после выполнения стирают эти записи. Это позволяет очень быстро понять была ли файловая система повреждена. Но не сильно помогает при восстановлении. Чтобы восстановить файловую систему linux необходимо проверить каждый блок файловой системы и найти поврежденные сектора.

Для этих целей используется утилита fsck. По сути, это оболочка для других утилит, ориентированных на работу только с той или иной файловой системой, например, для fat одна утилита, а для ext4 совсем другая.

В большинстве систем для корневого раздела проверка fsck запускается автоматически, но это не касается других разделов, а также не сработает если вы отключили проверку.

### Основы работы с fsck

В этой статье мы рассмотрим ручную работу с fsck. Возможно, вам понадобиться LiveCD носитель, чтобы запустить из него утилиту, если корневой раздел поврежден. Если же нет, то система сможет загрузиться в режим восстановления и вы будете использовать утилиту оттуда. Также вы можете запустить fsck в уже загруженной системе. Только для работы нужны права суперпользователя, поэтому выполняйте ее через sudo.

Рассмотрим сам синтаксис утилиты:

```bash
$ fsck [опции] [опции_файловой_системы] [раздел_диска]
```

Основные опции указывают способ поведения утилиты, оболочки fsck. Раздел диска - это файл устройства раздела в каталоге /dev, например, /dev/sda1 или /dev/sda2. Опции файловой системы специфичны для каждой отдельной утилиты проверки.

Теперь рассмотрим самые полезные опции fsck:

-   **-l** - не выполнять другой экземпляр fsck для этого жесткого диска, пока текущий не завершит работу. Для SSD параметр игнорируется;
-   **-t** - задать типы файловых систем, которые нужно проверить. Необязательно указывать устройство, можно проверить несколько разделов одной командой, просто указав нужный тип файловой системы. Это может быть сама файловая система, например, ext4 или ее опции в формате opts=ro. Утилита просматривает все файловые системы, подключенные в fstab. Если задать еще и раздел то к нему будет применена проверка именно указанного типа, без автоопределения;
-   **-A** - проверить все файловые системы из /etc/fstab. Вот тут применяются параметры проверки файловых систем, указанные в /etc/fstab, в том числе и приоритетность. В первую очередь проверяется корень. Обычно используется при старте системы;
-   **-C** - показать прогресс проверки файловой системы;
-   **-M** - не проверять, если файловая система смонтирована;
-   **-N** - ничего не выполнять, показать, что проверка завершена успешно;
-   **-R** - не проверять корневую файловую систему;
-   **-T** - не показывать информацию об утилите;
-   **-V** - максимально подробный вывод.

Это были глобальные опции утилиты. Теперь опции для работы с файловой системой, их меньше, но они будут более интересны:

-   **-a** - во время проверки исправить все обнаруженные ошибки, без каких-либо вопросов. Опция устаревшая и ее использовать не рекомендуется;
-   **-n** - выполнить только проверку файловой системы, ничего не исправлять;
-   **-r** - спрашивать перед исправлением каждой ошибки, используется по умолчанию для файловых систем ext;
-   **-y** - отвечает на все вопросы об исправлении ошибок утвердительно, можно сказать, что это эквивалент a.
-   **-c** - найти и занести в черный список все битые блоки на жестком диске. Доступно только для ext3 и ext4;
-   **-f** - принудительная проверка файловой системы, даже если по журналу она чистая;
-   **-b** - задать адрес суперблока, если основной был поврежден;
-   **-p** - еще один современный аналог опции -a, выполняет проверку и исправление автоматически. По сути, для этой цели можно использовать одну из трех опций: p, a, y.

### Как восстановить файловую систему в fsck

Допустим, мы загрузились в LiveCD систему или режим восстановления. Ну, одним словом, готовы к восстановлению ext4 или любой другой поврежденной ФС. Утилита уже установлена по умолчанию во всех дистрибутивах, так что устанавливать ничего не нужно.

### Восстановление файловой системы

Если ваша файловая система находится на разделе с адресом /dev/sda1 выполните:

```bash
sudo fsck -y /dev/sda1
```

[![fsck3](https://losst.pro/wp-content/uploads/2016/09/fsck3.png)](https://losst.pro/wp-content/uploads/2016/09/fsck3.png)

Опцию y указывать необязательно, но если этого не сделать утилита просто завалит вас вопросами, на которые нужно отвечать да.

### Восстановление поврежденного суперблока

Обычно эта команда справляется со всеми повреждениями на ура. Но если вы сделали что-то серьезное и повредили суперблок, то тут fsck может не помочь. Суперблок - это начало файловой системы. Без него ничего работать не будет.

Но не спешите прощаться с вашими данными, все еще можно восстановить. С помощью такой команды смотрим куда были записаны резервные суперблоки:

```bash
sudo mkfs -t ext4 -n /dev/sda1
```

[![fsck1](https://losst.pro/wp-content/uploads/2016/09/fsck1.png)](https://losst.pro/wp-content/uploads/2016/09/fsck1.png)

На самом деле эта команда создает новую файловую систему. Вместо ext4 подставьте ту файловую систему, в которую был отформатирован раздел, размер блока тоже должен совпадать иначе ничего не сработает. С опцией -n никаких изменений на диск не вноситься, а только выводится информация, в том числе о суперблоках.

Теперь у нас есть шесть резервных адресов суперблоков и мы можем попытаться восстановить файловую систему с помощью каждого из них, например:

```bash
sudo fsck -b 98304 /dev/sda1
```

[![fsck2](https://losst.pro/wp-content/uploads/2016/09/fsck2.png)](https://losst.pro/wp-content/uploads/2016/09/fsck2.png)

После этого, скорее всего, вам удастся восстановить вашу файловую систему. Но рассмотрим еще пару примеров.

### Проверка чистой файловой системы

Проверим файловую систему, даже если она чистая:

```bash
sudo fsck -fy /dev/sda1
```

[![fsck4](https://losst.pro/wp-content/uploads/2016/09/fsck4.png)](https://losst.pro/wp-content/uploads/2016/09/fsck4.png)

### Битые сектора

Или еще мы можем найти битые сектора и больше в них ничего не писать:

```bash
sudo fsck -c /dev/sda1
```

[![fsck5](https://losst.pro/wp-content/uploads/2016/09/fsck5.png)](https://losst.pro/wp-content/uploads/2016/09/fsck5.png)

### Установка файловой системы

Вы можете указать какую файловую систему нужно проверять на разделе, например:

```bash
sudo fsck -t ext4 /dev/sdb1
```

[![fsck6](https://losst.pro/wp-content/uploads/2016/09/fsck6.png)](https://losst.pro/wp-content/uploads/2016/09/fsck6.png)

### Проверка всех файловых систем

С помощью флага -A вы можете проверить все файловые системы, подключенные к компьютеру:

```bash
sudo fsck -A -y
```

Но такая команда сработает только в режиме восстановления, если корневой раздел и другие разделы уже примонтированы она выдаст ошибку. Но вы можете исключить корневой раздел из проверки добавив R:

```bash
sudo fsck -AR -y
```

Или исключить все примонтированные файловые системы:

```bash
sudo fsck -M -y
```

Также вы можете проверить не все файловые системы, а только ext4, для этого используйте такую комбинацию опций:

```bash
sudo fsck -A -t ext4 -y
```

Или можно также фильтровать по опциям монтирования в /etc/fstab, например, проверим файловые системы, которые монтируются только для чтения:

```bash
sudo fsck -A -t opts=ro
```

### Проверка примонтированных файловых систем

Раньше я говорил что нельзя. Но если другого выхода нет, то можно, правда не рекомендуется. Для этого нужно сначала перемонтировать файловую систему в режим только для чтения. Например:

```bash
sudo mount -o remount,ro /dev/sdb1
```

А теперь проверка файловой системы fsck в принудительном режиме:

```bash
sudo fsck -fy /dev/sdb1
```

[![fsck7](https://losst.pro/wp-content/uploads/2016/09/fsck7.png)](https://losst.pro/wp-content/uploads/2016/09/fsck7.png)

### Просмотр информации

Если вы не хотите ничего исправлять, а только посмотреть информацию, используйте опцию -n:

```bash
sudo fsck -n /dev/sdb1
```

[![fsck8](https://losst.pro/wp-content/uploads/2016/09/fsck8.png)](https://losst.pro/wp-content/uploads/2016/09/fsck8.png)

## Дефрагментация

При использовании носителей информации неизбежно возникает **фрагментация данных** — разбиение файлов на блоки, которые записываются в разных областях носителя. Поговорим о том, как исправить излишнюю фрагментацию данных в Linux.

Первым делом нужно сказать, что процедуру дефрагментации рекомендуется проводить **только для жёстких дисков**. Flash-накопители и SSD используют метод прямого доступа к памяти. Это значит, что время обращения к любой ячейке сравнительно мало, а её местонахождение становится не таким уж важным. Более того, поскольку количество циклов перезаписи у таких накопителей всё ещё меньше, чем у жёстких дисков, дефрагментация может наносить урон по продолжительности «жизни» накопителя. А вот позиционирующим головкам внутри жёстких дисков после дефрагментации приходится меньше перемещаться, что позитивно сказывается на времени обращения к файлам.

В Linux-сообществе нет единодушной позиции относительно того, полезна или бесполезна процедура дефрагментации в Linux. Дело в том, что файловые системы ext2, ext3 и ext4 стараются равномерно «раскидывать» новые файлы по диску. Если файл увеличивается в объёме, файловая система использует всё свободное пространство вокруг него. Если фрагментация всё же происходит, то файловая система старается в фоновом режиме переносить файлы в те места, где их фрагменты могут быть объединены. Успех? Не совсем.

Вышеописанные процедуры хорошо работают с дисками, у которых сравнительно много незанятого пространства. Но когда количество свободного пространства уменьшается, фрагментация становится возможной.

Для проведения дефрагментации в Linux можно использовать утилиты **`e2defrag`** и **`e4defrag`** (для ext2 и ext4 соответственно). Утилита e2defrag может работать и с ext3, но только при условии временного преобразования файловой системы в ext2. Есть и другой способ — утилита **`Shake`**, которая может работать с разными файловыми системами.

Допустим, что нам нужно оценить, нуждается ли в дефрагментации раздел _/dev/sda2_. Это делается командой

```bash
sudo e4defrag -c /dev/sda2
```

Время выполнения команды зависит от того объёма информации, что предстоит проанализировать утилите. По окончании анализа вы увидите отчёт.

![Дефрагментация в Linux](https://webistore.ru/wp-content/uploads/2019/10/defragmentation_linux_01.png)

Если вы видите надпись «This device does not need defragmentation», то дефрагментация диску (разделу) не требуется.

Нужна ли дефрагментация можно также определить по значению **Fragmentation score**. Если оно лежит в диапазон от 0 до 30, то дефрагментация не требуется. Если значение представляет собой число от 31 до 55, то есть небольшие проблемы с фрагментацией файлов. При Fragmentation score от 56 и выше нужно провести процедуру дефрагментации.

Если вы хотите провести принудительную процедуру дефрагментации, воспользуйтесь командой

```bash
sudo e4defrag -v /dev/sda2
```

Естественно, если нужно произвести дефрагментацию другого раздела, то вместо _/dev/sda2_ следует указать нужное имя.

![Дефрагментация в Linux](https://webistore.ru/wp-content/uploads/2019/10/defragmentation_linux_02.png)

По итогам работы команды следует обратить внимание на показатель **Fragmented percentage**. Он показывает сколько было фрагментированных файлов и сколько стало. В нашем случае всё было хорошо и до дефрагментации, поэтому эта процедура толком ничего не изменила. Но бывают ситуации и похуже.

Теперь посмотрим на утилиту [Shake](http://vleu.net/shake/). Это тоже весьма полезный дефрагментатор, который работает на основе эвристики и не требует внесения изменений в ядро или остановки работы системы. Суть работы утилиты Shake в том, что она просто перемещает файлы.

В целом, пользоваться утилитой очень просто — достаточно указать файл или каталог, который необходимо переместить.

```bash
sudo shake /home/test/
```

Командой выше мы переместили файлы в каталоге _/home/test_.

Если необходимо только посмотреть, насколько сильно фрагментирован файл или каталог, нужно использовать опции —pretend—verbose —verbose или -pvv

```bash
sudo shake -pvv /home/test/
```

Можно использовать и более сложные конструкции. Команда ниже проведёт дефрагментацию всех mp3-файлов в каталоге и рассортирует их.

```bash
find -iname '*.mp3' | sort | shake
```

Для более эффективной работы утилиты её автор рекомендует включать расширенные пользовательские атрибуты (user_xattr).

Shake нечасто встретишь в репозиториях. У программы есть [страница на GitHub](https://github.com/unbrice/shake), а также [PPA-репозиторий](https://launchpad.net/~un-brice/+archive/ubuntu/ppa) .

Более подробно о синтаксисе Shake вам подскажет справка, которую можно вызвать командой

```bash
shake -h
```

![Дефрагментация в Linux](https://webistore.ru/wp-content/uploads/2019/10/defragmentation_linux_03.png)

Итак, фрагментация файлов в Linux имеет место быть. Она не является острой проблемой благодаря достоинствам файловых систем ext2, ext3 и ext4. Однако, если жёсткий диск или раздел забит файлами, рекомендуется периодически проводить проверку на наличие фрагментации.